# 模块8: 研发工程提效

## 课程概述

本模块聚焦AI技术在研发工程领域的应用，包括AI辅助编程、智能测试、Text-to-SQL等技术，通过ChatBI项目实战，帮助学员掌握利用AI提升研发效率的完整方法论。

---

## 第一章：智能编码革命：AI辅助编程

### 1.1 AI辅助编程与Vibe Coding

#### 1.1.1 AI辅助编程的核心理念

**AI编程助手的能力范围：**

```
┌─────────────────────────────────────────────────────────────┐
│                  AI编程助手能力图谱                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  代码生成                                                    │
│  ├── 从自然语言生成代码                                      │
│  ├── 函数/类自动补全                                        │
│  ├── 样板代码生成                                           │
│  └── 测试用例生成                                           │
│                                                             │
│  代码理解                                                    │
│  ├── 代码解释与文档生成                                      │
│  ├── 代码库问答                                             │
│  ├── 依赖分析                                               │
│  └── 架构理解                                               │
│                                                             │
│  代码优化                                                    │
│  ├── 重构建议                                               │
│  ├── 性能优化                                               │
│  ├── 安全漏洞检测                                           │
│  └── 代码风格统一                                           │
│                                                             │
│  调试辅助                                                    │
│  ├── 错误分析与修复建议                                      │
│  ├── 日志分析                                               │
│  └── 问题根因定位                                           │
│                                                             │
│  学习辅助                                                    │
│  ├── 概念解释                                               │
│  ├── 最佳实践推荐                                           │
│  └── 技术方案比较                                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 1.1.2 Vibe Coding详解：什么是心流开发

**Vibe Coding定义：**

Vibe Coding是一种与AI协同编程的新模式，开发者用自然语言描述意图，AI生成代码，形成人机协作的"心流"状态。

```
传统编程流程：
需求 → 思考实现 → 编写代码 → 调试 → 优化
      （耗时多）   （手动敲）  （反复）

Vibe Coding流程：
需求 → 描述意图 → AI生成 → 审查修改 → 迭代优化
      （自然语言） （秒级）  （快速）
```

**Vibe Coding的核心原则：**

```python
# 原则1：描述意图而非实现
# ❌ 不好的提示
"用for循环遍历列表，用if判断是否大于10"

# ✅ 好的提示
"过滤出列表中大于10的元素"

# 原则2：提供上下文
# ❌ 缺少上下文
"写一个登录函数"

# ✅ 提供上下文
"""
我们使用Flask框架，用户数据存储在PostgreSQL中。
请写一个登录API，需要：
- 验证邮箱和密码
- 使用bcrypt验证密码
- 登录成功返回JWT token
"""

# 原则3：迭代优化
# 第一轮：生成基础代码
"写一个用户注册函数"

# 第二轮：添加验证
"添加邮箱格式验证和密码强度检查"

# 第三轮：添加错误处理
"添加完善的错误处理和日志记录"
```

#### 1.1.3 高效使用AI编程助手

**代码生成最佳实践：**

```python
# 场景1：从需求生成代码
"""
任务：实现一个LRU缓存

要求：
- 容量可配置
- 支持get和put操作
- get和put都是O(1)时间复杂度
- 线程安全
"""

# AI生成的代码
from collections import OrderedDict
import threading

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity
        self.lock = threading.Lock()

    def get(self, key: str):
        with self.lock:
            if key not in self.cache:
                return None
            self.cache.move_to_end(key)
            return self.cache[key]

    def put(self, key: str, value):
        with self.lock:
            if key in self.cache:
                self.cache.move_to_end(key)
            self.cache[key] = value
            if len(self.cache) > self.capacity:
                self.cache.popitem(last=False)


# 场景2：代码解释
"""
解释以下代码的作用和实现原理：
[粘贴代码]
"""

# 场景3：代码重构
"""
重构以下代码，使其更加清晰和可维护：
- 提取重复逻辑为函数
- 添加类型注解
- 改善命名
[粘贴代码]
"""

# 场景4：调试帮助
"""
以下代码报错：[错误信息]
代码：[粘贴代码]
请分析原因并给出修复方案
"""
```

### 1.2 CASE：多张Excel报表处理

```python
"""
任务：合并多张Excel报表，进行数据清洗和分析

使用AI生成完整解决方案
"""

# 提示词：
"""
我需要处理多张Excel销售报表，完成以下任务：
1. 读取目录下所有Excel文件
2. 合并为一个DataFrame
3. 数据清洗：
   - 去除重复行
   - 处理缺失值
   - 日期格式统一
   - 金额列转为数值类型
4. 生成分析报告：
   - 按月份统计销售额
   - 按产品分类统计
   - 同比环比分析
5. 导出结果到新的Excel文件

请使用pandas实现
"""

# AI生成的代码
import pandas as pd
import numpy as np
from pathlib import Path
from datetime import datetime

class ExcelReportProcessor:
    def __init__(self, input_dir: str, output_file: str):
        self.input_dir = Path(input_dir)
        self.output_file = output_file
        self.df = None

    def read_all_excel(self):
        """读取目录下所有Excel文件"""
        all_dfs = []
        excel_files = list(self.input_dir.glob("*.xlsx")) + list(self.input_dir.glob("*.xls"))

        for file in excel_files:
            try:
                df = pd.read_excel(file)
                df['source_file'] = file.name
                all_dfs.append(df)
                print(f"已读取: {file.name}, {len(df)}行")
            except Exception as e:
                print(f"读取失败: {file.name}, 错误: {e}")

        self.df = pd.concat(all_dfs, ignore_index=True)
        print(f"总计合并: {len(self.df)}行")
        return self

    def clean_data(self):
        """数据清洗"""
        # 去重
        before_count = len(self.df)
        self.df = self.df.drop_duplicates()
        print(f"去重: {before_count - len(self.df)}行")

        # 处理缺失值
        # 数值列填充0
        numeric_cols = self.df.select_dtypes(include=[np.number]).columns
        self.df[numeric_cols] = self.df[numeric_cols].fillna(0)

        # 文本列填充'未知'
        text_cols = self.df.select_dtypes(include=['object']).columns
        self.df[text_cols] = self.df[text_cols].fillna('未知')

        # 日期格式统一
        if '日期' in self.df.columns:
            self.df['日期'] = pd.to_datetime(self.df['日期'], errors='coerce')
            self.df['年月'] = self.df['日期'].dt.to_period('M')

        # 金额转数值
        if '金额' in self.df.columns:
            self.df['金额'] = pd.to_numeric(
                self.df['金额'].astype(str).str.replace(',', '').str.replace('¥', ''),
                errors='coerce'
            ).fillna(0)

        return self

    def analyze(self):
        """生成分析报告"""
        analysis = {}

        # 按月份统计
        if '年月' in self.df.columns and '金额' in self.df.columns:
            monthly = self.df.groupby('年月')['金额'].sum().reset_index()
            monthly.columns = ['月份', '销售额']
            # 环比
            monthly['环比'] = monthly['销售额'].pct_change() * 100
            analysis['monthly_sales'] = monthly

        # 按产品分类
        if '产品类别' in self.df.columns:
            category = self.df.groupby('产品类别')['金额'].agg(['sum', 'count', 'mean'])
            category.columns = ['总销售额', '订单数', '平均单价']
            analysis['category_sales'] = category

        # 汇总统计
        analysis['summary'] = {
            '总销售额': self.df['金额'].sum() if '金额' in self.df.columns else 0,
            '总订单数': len(self.df),
            '平均单价': self.df['金额'].mean() if '金额' in self.df.columns else 0,
        }

        return analysis

    def export(self, analysis):
        """导出结果"""
        with pd.ExcelWriter(self.output_file, engine='openpyxl') as writer:
            # 原始数据
            self.df.to_excel(writer, sheet_name='原始数据', index=False)

            # 月度分析
            if 'monthly_sales' in analysis:
                analysis['monthly_sales'].to_excel(writer, sheet_name='月度分析', index=False)

            # 分类分析
            if 'category_sales' in analysis:
                analysis['category_sales'].to_excel(writer, sheet_name='分类分析')

            # 汇总
            pd.DataFrame([analysis['summary']]).to_excel(writer, sheet_name='汇总', index=False)

        print(f"结果已导出到: {self.output_file}")

    def run(self):
        """执行完整流程"""
        self.read_all_excel()
        self.clean_data()
        analysis = self.analyze()
        self.export(analysis)
        return analysis


# 使用
processor = ExcelReportProcessor(
    input_dir="./sales_reports",
    output_file="./analysis_result.xlsx"
)
result = processor.run()
```

### 1.3 国内外AI编程工具对比

#### 1.3.1 主流工具解析

**Cursor编辑器：**

```
Cursor特点：
├── 基于VSCode，熟悉的界面
├── 原生AI集成
│   ├── Cmd+K：生成代码
│   ├── Cmd+L：聊天对话
│   └── Tab：智能补全
├── 代码库理解
│   └── 可以索引整个项目
├── 多模型支持
│   └── GPT-4, Claude, 自定义
└── 特色功能
    ├── Composer：多文件编辑
    └── @符号引用文件/文档

使用技巧：
1. 使用@符号引用上下文
   @file:utils.py 参考这个文件的风格

2. 使用Composer做多文件修改
   "在所有API文件中添加日志记录"

3. 使用聊天理解代码库
   "解释这个项目的架构"
```

**GitHub Copilot：**

```
Copilot特点：
├── 深度集成GitHub生态
├── 行级和函数级补全
├── 支持多种IDE
│   └── VSCode, JetBrains, Neovim
├── Copilot Chat
│   └── 对话式编程
└── Copilot Workspace（预览）
    └── Issue到PR的自动化

最佳实践：
1. 写好注释让Copilot理解意图
   # 实现一个线程安全的单例模式

2. 使用注释引导生成
   # TODO: 添加参数验证

3. 使用Copilot Chat进行调试
   /fix 这段代码有什么问题
```

#### 1.3.2 工具横向对比

```
┌─────────────────────────────────────────────────────────────┐
│                AI编程工具对比                               │
├──────────┬──────────┬──────────┬──────────┬────────────────┤
│   工具   │ Cursor   │ Copilot  │  Trae    │  通义灵码     │
├──────────┼──────────┼──────────┼──────────┼────────────────┤
│ 开发商   │ Cursor   │ GitHub   │ 字节     │ 阿里          │
│ 定价     │ $20/月   │ $10/月   │ 免费     │ 免费/付费     │
│ 模型     │ GPT-4/   │ GPT-4    │ 豆包     │ 通义千问      │
│          │ Claude   │          │          │               │
│ IDE支持  │ 独立IDE  │ 插件     │ VSCode   │ VSCode/       │
│          │          │          │ 插件     │ JetBrains     │
│ 代码补全 │ ⭐⭐⭐⭐⭐ │ ⭐⭐⭐⭐⭐ │ ⭐⭐⭐⭐  │ ⭐⭐⭐⭐       │
│ 对话能力 │ ⭐⭐⭐⭐⭐ │ ⭐⭐⭐⭐  │ ⭐⭐⭐⭐  │ ⭐⭐⭐⭐       │
│ 代码库   │ ⭐⭐⭐⭐⭐ │ ⭐⭐⭐    │ ⭐⭐⭐   │ ⭐⭐⭐         │
│ 理解     │          │          │          │               │
│ 中文支持 │ ⭐⭐⭐⭐  │ ⭐⭐⭐    │ ⭐⭐⭐⭐⭐│ ⭐⭐⭐⭐⭐      │
├──────────┴──────────┴──────────┴──────────┴────────────────┤
│                                                             │
│  选型建议：                                                  │
│  ├── 英文项目、追求最佳体验 → Cursor                        │
│  ├── 已有GitHub订阅 → Copilot                               │
│  ├── 免费使用、中文项目 → 通义灵码/Trae                     │
│  └── 企业内网部署 → 通义灵码企业版                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 第二章：AI赋能的智能测试与质量保障

### 2.1 AI用例生成与智能测试

#### 2.1.1 基于PRD的用例生成

```python
"""
使用AI从需求文档自动生成测试用例
"""

class TestCaseGenerator:
    def __init__(self, llm):
        self.llm = llm

    def generate_from_prd(self, prd_content: str) -> list:
        """从PRD生成测试用例"""
        prompt = f"""请根据以下产品需求文档，生成完整的测试用例。

需求文档：
{prd_content}

请生成测试用例，包含以下内容：
1. 功能测试用例
   - 正常流程测试
   - 边界条件测试
   - 异常情况测试

2. 用例格式：
   - 用例ID
   - 用例名称
   - 前置条件
   - 测试步骤
   - 预期结果
   - 优先级（P0-P3）

请以JSON格式输出：
"""

        response = self.llm.generate(prompt)
        test_cases = self.parse_response(response)
        return test_cases

    def generate_edge_cases(self, function_desc: str) -> list:
        """生成边界测试用例"""
        prompt = f"""针对以下功能，生成边界值和异常情况测试用例：

功能描述：{function_desc}

请考虑：
1. 数值边界（最大值、最小值、零、负数）
2. 字符串边界（空字符串、超长字符串、特殊字符）
3. 空值/null情况
4. 并发情况
5. 权限边界
6. 时间边界

以JSON格式输出测试用例：
"""
        response = self.llm.generate(prompt)
        return self.parse_response(response)


# 使用示例
generator = TestCaseGenerator(llm)

prd = """
用户注册功能需求：
1. 用户输入邮箱、密码、确认密码进行注册
2. 邮箱格式需符合标准格式
3. 密码长度8-20位，需包含大小写字母和数字
4. 确认密码需与密码一致
5. 邮箱不能重复注册
6. 注册成功后发送验证邮件
"""

test_cases = generator.generate_from_prd(prd)
for case in test_cases:
    print(f"用例: {case['name']}")
    print(f"步骤: {case['steps']}")
    print(f"预期: {case['expected']}")
    print("---")
```

#### 2.1.2 基于代码的单元测试生成

```python
"""
AI自动生成单元测试
"""

def generate_unit_tests(source_code: str, llm) -> str:
    """为Python代码生成单元测试"""
    prompt = f"""请为以下Python代码生成完整的单元测试。

源代码：
```python
{source_code}
```

要求：
1. 使用pytest框架
2. 覆盖所有公开方法
3. 包含正常情况和异常情况
4. 使用参数化测试减少重复
5. Mock外部依赖
6. 目标覆盖率>90%

请生成完整的测试代码：
"""

    test_code = llm.generate(prompt)
    return test_code


# 示例：为LRU Cache生成测试
lru_cache_code = '''
class LRUCache:
    def __init__(self, capacity: int):
        self.cache = {}
        self.capacity = capacity

    def get(self, key: str):
        if key not in self.cache:
            return None
        return self.cache[key]

    def put(self, key: str, value):
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            oldest = next(iter(self.cache))
            del self.cache[oldest]
'''

# AI生成的测试代码
generated_tests = """
import pytest
from lru_cache import LRUCache

class TestLRUCache:
    @pytest.fixture
    def cache(self):
        return LRUCache(capacity=3)

    def test_init(self, cache):
        assert cache.capacity == 3
        assert len(cache.cache) == 0

    def test_put_and_get(self, cache):
        cache.put("a", 1)
        assert cache.get("a") == 1

    def test_get_nonexistent(self, cache):
        assert cache.get("nonexistent") is None

    def test_capacity_eviction(self, cache):
        cache.put("a", 1)
        cache.put("b", 2)
        cache.put("c", 3)
        cache.put("d", 4)  # 超出容量，应该删除最早的
        assert len(cache.cache) == 3
        assert cache.get("a") is None  # a应该被删除

    def test_update_existing(self, cache):
        cache.put("a", 1)
        cache.put("a", 2)
        assert cache.get("a") == 2
        assert len(cache.cache) == 1

    @pytest.mark.parametrize("key,value", [
        ("", "empty_key"),
        ("key", ""),
        ("key", None),
        ("key", 0),
    ])
    def test_edge_cases(self, cache, key, value):
        cache.put(key, value)
        assert cache.get(key) == value
"""
```

### 2.2 AI驱动的测试流程优化

#### 2.2.1 智能缺陷定位

```python
class AIDebugger:
    """AI辅助调试器"""

    def __init__(self, llm):
        self.llm = llm

    def analyze_error(self, error_message: str, code_context: str,
                      stack_trace: str) -> dict:
        """分析错误并给出修复建议"""
        prompt = f"""请分析以下错误并给出修复建议：

错误信息：
{error_message}

堆栈跟踪：
{stack_trace}

相关代码：
```python
{code_context}
```

请分析：
1. 错误的根本原因
2. 问题发生的位置
3. 具体的修复方案
4. 如何避免类似问题

以JSON格式返回分析结果：
"""

        analysis = self.llm.generate(prompt)
        return self.parse_analysis(analysis)

    def suggest_fix(self, code: str, error: str) -> str:
        """生成修复代码"""
        prompt = f"""以下代码存在错误，请修复：

原代码：
```python
{code}
```

错误：{error}

请返回修复后的完整代码：
"""
        return self.llm.generate(prompt)


# 使用示例
debugger = AIDebugger(llm)

result = debugger.analyze_error(
    error_message="TypeError: 'NoneType' object is not subscriptable",
    code_context="""
def get_user_name(user):
    return user['name']

result = get_user_name(None)
""",
    stack_trace="..."
)

print(f"原因: {result['root_cause']}")
print(f"修复: {result['fix_suggestion']}")
```

#### 2.2.2 构建AI驱动的CI/CD质量门禁

```yaml
# .github/workflows/ai-quality-gate.yml

name: AI Quality Gate

on: [push, pull_request]

jobs:
  ai-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v35

      - name: AI Code Review
        uses: your-org/ai-code-review-action@v1
        with:
          files: ${{ steps.changed-files.outputs.all_changed_files }}
          api-key: ${{ secrets.OPENAI_API_KEY }}
          rules: |
            - 检查潜在的安全漏洞
            - 检查性能问题
            - 检查代码风格
            - 检查测试覆盖

      - name: AI Test Generation
        run: |
          # 为新代码自动生成测试
          python scripts/ai_test_generator.py \
            --files "${{ steps.changed-files.outputs.all_changed_files }}"

      - name: Run Tests
        run: pytest --cov=src --cov-report=xml

      - name: AI Coverage Analysis
        run: |
          python scripts/ai_coverage_analyzer.py \
            --coverage-file coverage.xml \
            --threshold 80

      - name: Comment PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            // 将AI分析结果作为PR评论
```

---

## 第三章：从Text-to-SQL到数据智能

### 3.1 Text-to-SQL智能查询引擎

#### 3.1.1 Text-to-SQL技术原理

```
┌─────────────────────────────────────────────────────────────┐
│                  Text-to-SQL工作流程                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  用户自然语言问题                                            │
│  "统计上个月销售额最高的前10个产品"                          │
│              ↓                                              │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              Schema理解                             │    │
│  │  解析数据库结构：表、列、关系、注释                   │    │
│  └─────────────────────────────────────────────────────┘    │
│              ↓                                              │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              意图解析                               │    │
│  │  理解用户意图：聚合、过滤、排序、TOP N               │    │
│  └─────────────────────────────────────────────────────┘    │
│              ↓                                              │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              SQL生成                                │    │
│  │  SELECT p.name, SUM(o.amount) as total              │    │
│  │  FROM products p                                    │    │
│  │  JOIN orders o ON p.id = o.product_id               │    │
│  │  WHERE o.order_date >= '2024-01-01'                 │    │
│  │  GROUP BY p.id                                      │    │
│  │  ORDER BY total DESC                                │    │
│  │  LIMIT 10                                           │    │
│  └─────────────────────────────────────────────────────┘    │
│              ↓                                              │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              验证与执行                             │    │
│  │  语法检查 → 权限检查 → 执行 → 结果格式化            │    │
│  └─────────────────────────────────────────────────────┘    │
│              ↓                                              │
│  结果展示（表格/图表）                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 3.1.2 构建SQL Copilot的关键挑战

```
Text-to-SQL核心挑战：

1. Schema理解
   ├── 表/列的语义理解
   ├── 表间关系推断
   └── 业务术语映射

2. 复杂查询处理
   ├── 多表JOIN
   ├── 子查询
   ├── 窗口函数
   └── CTE（公共表表达式）

3. 歧义处理
   ├── "上个月"是自然月还是最近30天？
   ├── "销售额"是含税还是不含税？
   └── 同名列的区分

4. 安全性
   ├── SQL注入防护
   ├── 权限控制
   └── 敏感数据保护

5. 性能
   ├── 生成高效SQL
   ├── 避免全表扫描
   └── 合理使用索引
```

#### 3.1.3 CASE：金融业务SQL Copilot

```python
class FinanceSQLCopilot:
    """金融业务SQL助手"""

    def __init__(self, llm, db_connection):
        self.llm = llm
        self.db = db_connection
        self.schema = self._load_schema()
        self.glossary = self._load_glossary()

    def _load_schema(self) -> str:
        """加载数据库Schema"""
        # 获取表结构信息
        schema_info = """
        数据库Schema：

        表：customers（客户表）
        - customer_id: 客户ID（主键）
        - name: 客户姓名
        - level: 客户等级（VIP/普通）
        - create_date: 开户日期

        表：transactions（交易表）
        - trans_id: 交易ID（主键）
        - customer_id: 客户ID（外键）
        - amount: 交易金额
        - trans_type: 交易类型（存款/取款/转账）
        - trans_date: 交易日期
        - status: 状态（成功/失败/处理中）

        表：products（理财产品表）
        - product_id: 产品ID（主键）
        - name: 产品名称
        - risk_level: 风险等级（低/中/高）
        - annual_rate: 年化收益率

        表：holdings（持仓表）
        - holding_id: 持仓ID
        - customer_id: 客户ID
        - product_id: 产品ID
        - amount: 持有金额
        - purchase_date: 购买日期
        """
        return schema_info

    def _load_glossary(self) -> dict:
        """加载业务术语表"""
        return {
            "AUM": "资产管理规模，即holdings表的amount总和",
            "活跃客户": "最近30天有交易的客户",
            "大额交易": "单笔金额超过10万的交易",
            "新客户": "开户不满3个月的客户",
        }

    def generate_sql(self, question: str) -> dict:
        """生成SQL"""
        # 构建提示词
        glossary_text = "\n".join([f"- {k}: {v}" for k, v in self.glossary.items()])

        prompt = f"""你是一个金融数据分析SQL专家。请根据用户问题生成SQL查询。

{self.schema}

业务术语：
{glossary_text}

用户问题：{question}

要求：
1. 生成标准SQL（MySQL语法）
2. 添加必要的注释
3. 考虑查询性能
4. 处理可能的NULL值
5. 使用有意义的别名

请返回JSON格式：
{{
    "sql": "生成的SQL语句",
    "explanation": "SQL逻辑解释",
    "assumptions": ["做出的假设"],
    "warnings": ["潜在问题提醒"]
}}
"""

        response = self.llm.generate(prompt)
        result = self.parse_json(response)

        # 验证SQL语法
        result["is_valid"] = self._validate_sql(result["sql"])

        return result

    def _validate_sql(self, sql: str) -> bool:
        """验证SQL语法"""
        try:
            # 使用EXPLAIN验证（不实际执行）
            self.db.execute(f"EXPLAIN {sql}")
            return True
        except Exception as e:
            return False

    def execute_and_explain(self, question: str) -> dict:
        """执行查询并解释结果"""
        # 生成SQL
        sql_result = self.generate_sql(question)

        if not sql_result["is_valid"]:
            return {"error": "SQL验证失败", "sql": sql_result["sql"]}

        # 执行查询
        try:
            data = self.db.execute(sql_result["sql"])

            # 让LLM解释结果
            explanation = self._explain_results(question, data)

            return {
                "sql": sql_result["sql"],
                "data": data,
                "explanation": explanation,
                "row_count": len(data)
            }
        except Exception as e:
            return {"error": str(e), "sql": sql_result["sql"]}

    def _explain_results(self, question: str, data) -> str:
        """解释查询结果"""
        prompt = f"""用户问题：{question}

查询结果：
{data[:10]}  # 只展示前10行

请用自然语言解释这个查询结果，突出关键发现：
"""
        return self.llm.generate(prompt)


# 使用示例
copilot = FinanceSQLCopilot(llm, db_connection)

# 查询示例
questions = [
    "统计各客户等级的AUM分布",
    "找出本月大额交易最多的前10位客户",
    "计算各理财产品的客户持有情况和平均持有金额",
    "分析新客户的首次交易金额分布"
]

for q in questions:
    result = copilot.execute_and_explain(q)
    print(f"问题: {q}")
    print(f"SQL: {result['sql']}")
    print(f"解释: {result['explanation']}")
    print("---")
```

---

## 第四章：项目实战——ChatBI开发

### 4.1 ChatBI的挑战与机遇

```
┌─────────────────────────────────────────────────────────────┐
│               传统BI vs 智能BI (ChatBI)                      │
├───────────────────────┬─────────────────────────────────────┤
│      传统BI           │           ChatBI                    │
├───────────────────────┼─────────────────────────────────────┤
│ 需要学习查询语言       │ 自然语言交互                        │
│ 预定义报表/仪表板      │ 动态生成分析                        │
│ 固定分析维度           │ 灵活探索                           │
│ 需要技术背景           │ 业务人员直接使用                    │
│ 改变分析需走开发流程    │ 即时响应                           │
├───────────────────────┴─────────────────────────────────────┤
│                                                             │
│  ChatBI核心能力：                                            │
│  ├── 自然语言理解：理解业务问题                              │
│  ├── 智能SQL生成：自动生成查询                              │
│  ├── 数据可视化：自动选择图表类型                            │
│  ├── 洞察生成：自动发现数据规律                              │
│  └── 对话式探索：支持追问和深挖                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 使用Vanna构建ChatBI

#### 4.2.1 Vanna核心工作流

```python
"""
Vanna是一个开源的Text-to-SQL框架
核心原理：RAG + SQL生成
"""

# 安装
# pip install vanna

from vanna.ollama import Ollama
from vanna.chromadb import ChromaDB_VectorStore

# 自定义Vanna类
class MyVanna(ChromaDB_VectorStore, Ollama):
    def __init__(self, config=None):
        ChromaDB_VectorStore.__init__(self, config=config)
        Ollama.__init__(self, config=config)

# 初始化
vn = MyVanna(config={
    'model': 'qwen:7b',  # 使用Ollama本地模型
    'ollama_host': 'http://localhost:11434'
})

# 连接数据库
vn.connect_to_sqlite('my_database.db')
# 或 vn.connect_to_postgres(...)
# 或 vn.connect_to_mysql(...)
```

#### 4.2.2 训练Vanna

```python
"""
Vanna的"训练"实际上是构建RAG知识库
包括：DDL、文档、SQL示例
"""

# 1. 训练DDL（数据库结构）
vn.train(ddl="""
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100),
    level VARCHAR(20) COMMENT '客户等级：VIP/普通',
    create_date DATE COMMENT '开户日期'
);
""")

vn.train(ddl="""
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    product_name VARCHAR(100),
    amount DECIMAL(10,2),
    order_date DATE,
    status VARCHAR(20)
);
""")

# 2. 训练文档（业务知识）
vn.train(documentation="""
业务术语说明：
- VIP客户：累计消费超过10万元的客户
- 活跃客户：最近30天有订单的客户
- 复购率：有2次及以上订单的客户比例
- GMV：订单总金额，不考虑退款
""")

# 3. 训练SQL示例（Few-shot）
vn.train(
    question="统计每个客户等级的客户数量",
    sql="""
    SELECT level, COUNT(*) as customer_count
    FROM customers
    GROUP BY level
    ORDER BY customer_count DESC
    """
)

vn.train(
    question="查询上月销售额前10的产品",
    sql="""
    SELECT product_name, SUM(amount) as total_sales
    FROM orders
    WHERE order_date >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH)
      AND order_date < CURDATE()
      AND status = 'completed'
    GROUP BY product_name
    ORDER BY total_sales DESC
    LIMIT 10
    """
)

# 4. 从数据库自动提取训练数据
# 自动获取Schema
df_ddl = vn.run_sql("SHOW CREATE TABLE customers")
vn.train(ddl=df_ddl)

# 获取信息Schema
df_info = vn.run_sql("SELECT * FROM information_schema.columns WHERE table_schema = 'mydb'")
```

#### 4.2.3 使用Vanna查询

```python
# 简单查询
sql = vn.generate_sql("有多少VIP客户？")
print(sql)
# SELECT COUNT(*) FROM customers WHERE level = 'VIP'

# 执行查询
df = vn.run_sql(sql)
print(df)

# 一步完成：生成SQL + 执行 + 可视化
result = vn.ask("各客户等级的月度销售趋势")
# 返回：SQL、数据、图表

# 获取生成过程的解释
sql = vn.generate_sql("复杂查询...")
explanation = vn.explain_sql(sql)
print(explanation)

# 带追问的对话
vn.ask("统计各产品类别的销售额")
vn.ask("按月份细分")  # 追问
vn.ask("只看VIP客户")  # 继续追问
```

#### 4.2.4 构建完整ChatBI应用

```python
import streamlit as st
from vanna.ollama import Ollama
from vanna.chromadb import ChromaDB_VectorStore
import plotly.express as px

class ChatBIApp:
    def __init__(self):
        self.vn = self._init_vanna()

    def _init_vanna(self):
        """初始化Vanna"""
        class MyVanna(ChromaDB_VectorStore, Ollama):
            def __init__(self, config=None):
                ChromaDB_VectorStore.__init__(self, config=config)
                Ollama.__init__(self, config=config)

        vn = MyVanna(config={'model': 'qwen:7b'})
        vn.connect_to_sqlite('business.db')
        return vn

    def run(self):
        st.title("ChatBI - 智能数据分析助手")

        # 侧边栏：数据库信息
        with st.sidebar:
            st.header("数据库信息")
            tables = self.vn.run_sql("SELECT name FROM sqlite_master WHERE type='table'")
            st.write("可用表：", tables)

        # 主界面：对话
        if "messages" not in st.session_state:
            st.session_state.messages = []

        # 显示历史消息
        for message in st.session_state.messages:
            with st.chat_message(message["role"]):
                st.write(message["content"])
                if "sql" in message:
                    st.code(message["sql"], language="sql")
                if "data" in message:
                    st.dataframe(message["data"])
                if "chart" in message:
                    st.plotly_chart(message["chart"])

        # 用户输入
        if prompt := st.chat_input("请输入您的数据分析问题..."):
            # 添加用户消息
            st.session_state.messages.append({"role": "user", "content": prompt})

            with st.chat_message("user"):
                st.write(prompt)

            # 生成回答
            with st.chat_message("assistant"):
                with st.spinner("分析中..."):
                    try:
                        # 生成SQL
                        sql = self.vn.generate_sql(prompt)
                        st.code(sql, language="sql")

                        # 执行查询
                        df = self.vn.run_sql(sql)
                        st.dataframe(df)

                        # 生成可视化
                        chart = self._auto_visualize(df, prompt)
                        if chart:
                            st.plotly_chart(chart)

                        # 生成洞察
                        insight = self._generate_insight(prompt, df)
                        st.write(insight)

                        # 保存消息
                        st.session_state.messages.append({
                            "role": "assistant",
                            "content": insight,
                            "sql": sql,
                            "data": df,
                            "chart": chart
                        })

                    except Exception as e:
                        st.error(f"分析失败: {str(e)}")

    def _auto_visualize(self, df, question):
        """自动选择合适的可视化"""
        if df.empty or len(df.columns) < 2:
            return None

        # 简单规则：根据数据特征选择图表
        if len(df) <= 10 and df.select_dtypes(include='number').columns.size == 1:
            # 少量数据 + 一个数值列 = 柱状图
            return px.bar(df, x=df.columns[0], y=df.columns[1])

        if 'date' in df.columns[0].lower() or '日期' in df.columns[0]:
            # 时间序列 = 折线图
            return px.line(df, x=df.columns[0], y=df.columns[1])

        # 默认柱状图
        return px.bar(df, x=df.columns[0], y=df.columns[1])

    def _generate_insight(self, question, df):
        """生成数据洞察"""
        prompt = f"""基于以下查询结果，生成简洁的数据洞察：

问题：{question}
数据：{df.to_string()}

请用2-3句话总结关键发现：
"""
        return self.vn.generate_summary(prompt)


# 运行应用
if __name__ == "__main__":
    app = ChatBIApp()
    app.run()
```

---

## 专项求职辅导

### 部署及提效相关面试问题

**1. Text-to-SQL的核心难点是什么？**

```
核心难点：

1. Schema理解
   - 表/列语义理解困难
   - 业务术语需要映射
   - 表间关系不明确

2. 复杂SQL生成
   - 多表JOIN
   - 嵌套子查询
   - 窗口函数

3. 歧义消解
   - 自然语言的多义性
   - 业务术语的特殊含义

4. 解决方案
   - RAG增强：检索相似SQL示例
   - Schema增强：添加列注释和业务说明
   - 迭代优化：SQL验证和自动修正
```

**2. 你如何使用AI编程工具提升编码效率？**

```
效率提升策略：

1. 代码生成
   - 用自然语言描述需求
   - 提供清晰的上下文
   - 迭代优化生成结果

2. 代码理解
   - 让AI解释复杂代码
   - 生成代码文档

3. 调试辅助
   - 分析错误信息
   - 获取修复建议

4. 测试生成
   - 自动生成单元测试
   - 边界用例发现

5. 代码评审
   - AI预审代码
   - 发现潜在问题

量化提升：
- 样板代码生成：提升3-5倍
- 调试时间：减少50%
- 测试覆盖：提升30%
```

**3. 如何利用AI优化测试流程？**

```
AI测试优化：

1. 用例生成
   - 从PRD自动生成用例
   - 边界值自动识别
   - 异常场景覆盖

2. 缺陷定位
   - 错误日志智能分析
   - 根因自动定位
   - 修复建议生成

3. 回归测试
   - 智能用例筛选
   - 影响范围分析
   - 优先级排序

4. CI/CD集成
   - 代码变更智能分析
   - 自动补充测试
   - 质量门禁
```

---

## 本模块总结

### 核心能力清单

1. **AI编程助手**：熟练使用Cursor/Copilot等工具
2. **Vibe Coding**：掌握人机协作编程方法
3. **智能测试**：能用AI生成测试用例和辅助调试
4. **Text-to-SQL**：理解原理，能构建SQL Copilot
5. **ChatBI开发**：能使用Vanna等工具构建智能BI

### 最佳实践

1. AI辅助≠完全依赖，需要人工审查
2. 提供清晰的上下文和约束
3. 迭代优化，而非一次完成
4. 建立质量验证机制
5. 持续学习新工具和方法
